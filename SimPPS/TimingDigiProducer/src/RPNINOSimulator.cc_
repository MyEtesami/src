#include "SimPPS/TimingDigiProducer/interface/RPVNINOSimulator.h"
//#include "SimTotem/RPDigiProducer/interface/RPVFATSimulator.h"
#include "Geometry/TotemRPDetTopology/interface/RPTopology.h"
#include <vector>
#include "TRandom.h"
#include <iostream>


RPNINOSimulator::RPNINOSimulator(const edm::ParameterSet &params, TimingId det_id)
//RPVFATSimulator::RPVFATSimulator(const edm::ParameterSet &params, RPDetId det_id)
 : params_(params), det_id_(det_id)
{
  trigger_mode_ = params_.getParameter<int>("RPNINOTriggerMode");
  threshold_ = params.getParameter<double>("RPNINOThreshold");
  dead_strip_probability_ = params.getParameter<double>("RPDeadStripProbability");
  dead_strips_simulation_on_ = params.getParameter<bool>("RPDeadStripSimulationOn");
  strips_no_ = RPTopology().DetStripNo();
  verbosity_ = params.getParameter<int>("RPVerbosity");
  links_persistence_ = params.getParameter<bool>("RPDigiSimHitRelationsPresistence");
  
cout<< "triggermode " <<trigger_mode_ <<endl;
  //trigger_mode: 0=no trigger, 1=one sector per chip, 2=4 sectors, 3=8 sectors, 4=gem mode (not implemented)
/*
  switch(trigger_mode_)
  {
    case 0: 
      strips_per_section_ = 0;
      break;
    case 1:
      strips_per_section_ = 128; //since we have 4 chips
      break;
    case 2:
      strips_per_section_ = 128/4; //since we have 4 chips
      break;
    case 3:
      strips_per_section_ = 128/8; //since we have 4 chips
      break;
    default:
      strips_per_section_ = 0;
  }
std::cout<<"strips_no_ "<<strips_no_<<std::endl;
*/
}

//void RPVFATSimulator::ConvertChargeToHits(const SimRP::strip_charge_map &signals, 
  //  SimRP::strip_charge_map_links_type &theSignalProvenance, 
  //  std::vector<RPStripDigi> &output_digi, std::vector<RPDetTrigger> &output_trig, 
  //  SimRP::DigiPrimaryMapType &output_digi_links, 
//    SimRP::TriggerPrimaryMapType &output_trig_links)
void RPNINOSimulator::ConvertTimeToHits(const SimRP::PhotoElectron_ArrTime_vec &signals,
    SimRP::PhotoElectron_ArrTime_map_links_type &theSignalProvenance,
    std::vector<RPLBarDigi> &output_digi, std::vector<RPTimingTrigger> &output_trig,
    SimRP::DigiPrimaryMapType &output_digi_links,
    SimRP::TriggerPrimaryMapType &output_trig_links)

{
  the_trig_cont_.clear();
  the_trig_cont_links_.clear();

//int strips_per_section_false = 0; //to test Trigger out put

  for(SimRP::PhotoElectron_ArrTime_vec::const_iterator i=signals.begin(); 
        i!=signals.end(); ++i)
  {
    //one threshold per hybrid
    unsigned short strip_no = i->first;
    double leadingTime = 1.0 ;
    double trailingTime = 10.0;
    if(i->second > threshold_ && (!dead_strips_simulation_on_ 
          || dead_strips_.find(strip_no)==dead_strips_.end() ))
    {
//      output_digi.push_back(RPStripDigi(det_id_, strip_no));
       output_digi.push_back(RPLBarDigi(det_id_, leadingTime ,  trailingTime  , strip_no));
      if(links_persistence_)
      {
        output_digi_links.push_back(theSignalProvenance[strip_no]);
        if(verbosity_)
        {
          std::cout<<"digi links size="<<theSignalProvenance[strip_no].size()<<std::endl;
          for(unsigned int u=0; u<theSignalProvenance[strip_no].size(); ++u)
          {
            std::cout<<"   digi: particle="<<theSignalProvenance[strip_no][u].first<<" energy [electrons]="<<theSignalProvenance[strip_no][u].second<<std::endl;
          }
        }
      }
   //  cout<< "strips_per_section_   " <<strips_per_section_ <<endl; 
    // if(!strips_per_section_)    ++strips_per_section_false; //to test Trigger out put
     // cout<< "  just to test " << strips_per_section_false << endl;
      if(strips_per_section_)
      {
int det_trig_section = strip_no/strips_per_section_;  cout<< "det_trig_section  : trigger content" <<det_trig_section<<  "strip no: "<<strip_no << " strips_per_section_"  << strips_per_section_ <<endl;
        the_trig_cont_.insert(det_trig_section);
        
        if(links_persistence_)
        {
          std::vector< std::pair<int, double> >::const_iterator j=theSignalProvenance[strip_no].begin();
          std::vector< std::pair<int, double> >::const_iterator end=theSignalProvenance[strip_no].end();
          for(; j!=end; ++j)
          {
            the_trig_cont_links_[det_trig_section][j->first]+=j->second;
          }
        }
      }        
    }
  }
  //                 cout << "********number of strips with false trigger mode" << strips_per_section_false<< endl;//to test Trigger out put
// cout << "detID "<< det_id_ <<"   the_trig_cont_.size()      " << the_trig_cont_.size() <<endl; 
  for(SimRP::TriggerContainer::const_iterator j=the_trig_cont_.begin();
      j!=the_trig_cont_.end(); ++j)
  {
    output_trig.push_back(RPTimingTrigger(det_id_, *j));
    if(links_persistence_)
    {
      std::map<int, double>::const_iterator k=the_trig_cont_links_[*j].begin();
      std::map<int, double>::const_iterator end=the_trig_cont_links_[*j].end();
      std::vector<std::pair<int, double> > links_vector(k, end);
      output_trig_links.push_back(links_vector);
      if(verbosity_)
      {
        std::cout<<"trigger links size="<<links_vector.size()<<std::endl;
        for(unsigned int u=0; u<links_vector.size(); ++u)
        {
          std::cout<<"   trigger: particle="<<links_vector[u].first<<" energy [electrons]="<<links_vector[u].second<<std::endl;
        }
        std::cout<<std::endl;
      }
    }
  }
cout << "detID "<< det_id_ << "   output_digi.size()      " << output_digi.size() <<endl;
cout << "detID "<< det_id_ << "   output_trig.size()      " << output_trig.size() <<endl;
  if(verbosity_)
  {
    for(unsigned int i=0; i<output_digi.size(); ++i)
    {
      std::cout<<"VFAT Simulator "<<output_digi[i].GetDetId()<<" "
          <<output_digi[i].GetStripNo()<<std::endl;

std::cout<<"VFAT Simulator New PPS leading time" <<output_digi[i].GetLeadingTime()<<"Trailing time :  "
          <<output_digi[i].GetTrailingTime()<<std::endl;
 
    }                      
  }
}

void RPVFATSimulator::SetDeadStrips()
{
  dead_strips_.clear();
  double dead_strip_number = gRandom->Binomial(strips_no_, dead_strip_probability_);
  
  for(int i=0; i<dead_strip_number; ++i)
  {
    dead_strips_.insert(gRandom->Integer(strips_no_));
  }
}

